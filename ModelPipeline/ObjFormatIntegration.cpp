#include <sstream>
#include <fstream>
#include "ModelPipelineConstants.h"
#include "ObjFormatIntegration.h"
#include "PipelineUtil.h"


std::string ObjFormatIntegration::GenerateObjData(const ModelData & model, const std::string & material)
{
	std::ostringstream str;
	
	str << "# Generated by ModelPipeline v" << ModelPipelineConstants::VERSION << "\n";
	
	// Material header
	if (!material.empty())
	{
		str << "mtllib " << material << "\n";
	}

	// Vertex positions
	for (unsigned int i = 0U; i < model.VertexCount; ++i)
	{
		const auto & v = model.VertexData[i];
		str << "v " << v.position.x << ", " << v.position.y << ", " << v.position.z << "\n";
	}

	// Texture coordinates
	if (!model.DetrmineIfTextureCoordsPresent())
	{
		str << "# WARNING: Model does not contain any texture coordinate data\n";
	}
	else
	{
		for (unsigned int i = 0U; i < model.VertexCount; ++i)
		{
			const auto & v = model.VertexData[i];
			str << "vt " << v.tex.x << ", " << v.tex.y << "\n";
		}
	}

	// Normal data
	if (!model.DetemineIfNormalDataPresent())
	{
		str << "# WARNING: Model does not contain any vertex normal data\n";
	}
	else
	{
		for (unsigned int i = 0U; i < model.VertexCount; ++i)
		{
			const auto & v = model.VertexData[i];
			str << "vn " << v.normal.x << ", " << v.normal.y << ", " << v.normal.z << "\n";
		}
	}

	// TODO: Can output tangent/binormal data here?  Or just rely on Assimp generating it whenever RJM file is generated?

	// Material reference if required
	if (!material.empty())
	{
		str << "usemtl material0\n";
	}

	// Face data; generated from consecutive triplets out of the model index buffer
	if (model.IndexCount == 0U)
	{
		str << "# WARNING: Model does not contain any index buffer data\n";
	}
	else
	{
		for (unsigned int i = 0U; i < model.IndexCount; i += 3U)
		{
			str << "f";
			for (unsigned int ix = 0U; ix < 3U; ++ix)
			{
				unsigned int index = (model.IndexData[i + ix] + 1);		// Obj face indices are 1-based, so convert from 0-based index buffer data
				str << " " << index << "/" << index << "/" << index;
			}
			str << "\n";
		}
	}

	return str.str();
}

bool ObjFormatIntegration::GenerateObjFile(const ModelData & model, fs::path target_file, const std::string & material)
{
	// Convert model to OBJ format
	std::string data = ObjFormatIntegration::GenerateObjData(model, material);
	if (data.empty())
	{
		return false;
	}

	// Attempt to save the data to file
	if (fs::exists(target_file)) fs::remove(target_file);
	PipelineUtil::WriteDataTofile(target_file, data);

	// Generate an associated material file if required
	if (!material.empty())
	{
		ObjFormatIntegration::GenerateMaterialFile(target_file, material);
	}

	return true;
}


fs::path ObjFormatIntegration::GetAssociatedMaterialFile(fs::path source_file)
{
	return fs::path(fs::absolute(source_file.parent_path()).string() + "/" + source_file.stem().string() + ".mtl");
}

void ObjFormatIntegration::GenerateMaterialFile(fs::path source_file, const std::string & material_texture)
{
	fs::path mtl_file = GetAssociatedMaterialFile(source_file);

	std::ofstream out(mtl_file.string());
	out << "# Generated by RJM->OBJ format converter\n";
	out << "# All model files are associated to at most one material\n\n";

	out << "newmtl material0\n";
	out << "Ka 1.000000 1.000000 1.000000\n";
	out << "Kd 1.000000 1.000000 1.000000\n";
	out << "Ks 0.000000 0.000000 0.000000\n";
	out << "Tr 1.000000\n";
	out << "illum 1\n";
	out << "Ns 0.000000\n";
	out << "map_Kd " << material_texture << "\n";

	out.close();
}